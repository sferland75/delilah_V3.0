// Delilah V3.0 Pattern Recognition - Pattern Matcher Generator
// This script generates pattern matchers based on the analysis results

const fs = require('fs');
const path = require('path');

// Paths
const ANALYSIS_RESULT_PATH = path.join(__dirname, '../pattern_repository/analysis_results/analysis_summary.json');
const PATTERN_MATCHER_OUTPUT = path.join(__dirname, '../src/utils/pdf-import/PatternMatcher.js');
const PATTERN_MATCHER_TEMPLATE = `// Auto-generated PatternMatcher.js
// Generated on ${new Date().toISOString()}
// Do not edit this file directly - use the generate-matchers.js script

class PatternMatcher {
  constructor() {
    // Section matchers with confidence weights
    this.sectionPatterns = SECTION_PATTERNS;
    
    // Contextual patterns that help identify sections
    this.contextualPatterns = CONTEXTUAL_PATTERNS;
  }
  
  /**
   * Detect sections in the PDF text
   * @param {string} text - Text content from PDF
   * @returns {Array} - Detected sections with content and confidence
   */
  detectSections(text) {
    if (!text || typeof text !== 'string') {
      console.error('Invalid text provided to detectSections');
      return [];
    }
  
    const lines = text.split('\\n');
    const sections = [];
    
    // Track the current section being built
    let currentSection = null;
    let currentSectionText = '';
    let lineIndex = 0;
    
    // Process each line
    while (lineIndex < lines.length) {
      const line = lines[lineIndex];
      const lowerLine = line.toLowerCase().trim();
      
      // Check if this line starts a new section
      const detectedSection = this.detectSectionStart(lowerLine, lineIndex, lines);
      
      if (detectedSection) {
        // If we were building a section, save it
        if (currentSection) {
          sections.push({
            section: currentSection.type,
            title: currentSection.title,
            content: currentSectionText.trim(),
            confidence: currentSection.confidence
          });
        }
        
        // Start a new section
        currentSection = detectedSection;
        currentSectionText = '';
      } else if (currentSection) {
        // Add line to current section
        currentSectionText += line + '\\n';
      }
      
      lineIndex++;
    }
    
    // Add the last section if there is one
    if (currentSection) {
      sections.push({
        section: currentSection.type,
        title: currentSection.title,
        content: currentSectionText.trim(),
        confidence: currentSection.confidence
      });
    }
    
    return sections;
  }
  
  /**
   * Detect if a line starts a new section
   * @param {string} line - The line (lowercase and trimmed)
   * @param {number} lineIndex - Current line index
   * @param {Array} allLines - All lines in the document
   * @returns {Object|null} - Detected section or null
   */
  detectSectionStart(line, lineIndex, allLines) {
    // Check each section pattern
    for (const [sectionType, patterns] of Object.entries(this.sectionPatterns)) {
      // Check each pattern
      for (const pattern of patterns) {
        // Direct match with pattern
        if (
          line === pattern.text ||
          line.startsWith(pattern.text + ':') ||
          line.startsWith(pattern.text + ' -') ||
          line.startsWith(pattern.text + '-') ||
          line.match(new RegExp(\`^\\\\d+\\\\.?\\\\s*\${pattern.text}\`, 'i'))
        ) {
          return {
            type: sectionType,
            title: line,
            confidence: pattern.confidence,
            pattern: pattern.text
          };
        }
      }
      
      // Check contextual patterns
      if (this.contextualPatterns[sectionType]) {
        // Look at context before and after this line
        const contextBefore = lineIndex > 0 ? allLines[lineIndex - 1].toLowerCase().trim() : '';
        const contextAfter = lineIndex < allLines.length - 1 ? allLines[lineIndex + 1].toLowerCase().trim() : '';
        
        // Check before context
        for (const beforePattern of this.contextualPatterns[sectionType].before) {
          if (contextBefore.includes(beforePattern.text) && 
              (line.length < 100) && // Only consider reasonably short lines
              !line.match(/^\\d+$/) && // Not just a number
              !line.match(/^page \\d+$/i) // Not a page indicator
          ) {
            return {
              type: sectionType,
              title: line,
              confidence: beforePattern.confidence * 0.8, // Lower confidence for contextual match
              pattern: 'contextBefore:' + beforePattern.text
            };
          }
        }
        
        // Check after context
        for (const afterPattern of this.contextualPatterns[sectionType].after) {
          if (contextAfter.includes(afterPattern.text) && 
              (line.length < 100) && // Only consider reasonably short lines
              !line.match(/^\\d+$/) && // Not just a number
              !line.match(/^page \\d+$/i) // Not a page indicator
          ) {
            return {
              type: sectionType,
              title: line,
              confidence: afterPattern.confidence * 0.8, // Lower confidence for contextual match
              pattern: 'contextAfter:' + afterPattern.text
            };
          }
        }
      }
    }
    
    return null;
  }
}

// Section patterns with confidence weights
const SECTION_PATTERNS = SECTION_PATTERNS_PLACEHOLDER;

// Contextual patterns that help identify sections
const CONTEXTUAL_PATTERNS = CONTEXTUAL_PATTERNS_PLACEHOLDER;

module.exports = PatternMatcher;
`;

/**
 * Generate pattern matchers from analysis results
 */
function generatePatternMatchers() {
  console.log('Generating pattern matchers from analysis results...');
  
  try {
    // Read analysis results
    if (!fs.existsSync(ANALYSIS_RESULT_PATH)) {
      console.error(`Analysis results not found at ${ANALYSIS_RESULT_PATH}`);
      console.error('Please run analyze-patterns.js first.');
      process.exit(1);
    }
    
    const analysisData = JSON.parse(fs.readFileSync(ANALYSIS_RESULT_PATH, 'utf8'));
    
    console.log('Processing analysis data...');
    console.log(`Found data for ${Object.keys(analysisData.sections).length} sections.`);
    
    // Generate section patterns
    const sectionPatterns = {};
    
    Object.entries(analysisData.patternMatches).forEach(([section, patterns]) => {
      sectionPatterns[section] = [];
      
      // Sort patterns by frequency (most common first)
      const sortedPatterns = Object.entries(patterns)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .slice(0, 10); // Take top 10 patterns
      
      // Add patterns with confidence scores
      sortedPatterns.forEach(([pattern, count]) => {
        const totalDocuments = analysisData.documents.processed;
        const confidence = count / totalDocuments; // Normalize by document count
        
        sectionPatterns[section].push({
          text: pattern,
          confidence: Math.min(confidence * 2, 0.95) // Scale up but cap at 0.95
        });
      });
      
      console.log(`Generated ${sectionPatterns[section].length} patterns for ${section}`);
    });
    
    // Generate contextual patterns
    const contextualPatterns = {};
    
    Object.entries(analysisData.contextualClues).forEach(([section, contexts]) => {
      contextualPatterns[section] = {
        before: [],
        after: []
      };
      
      // Process lines that appear before the section
      const beforeLines = Object.entries(contexts.beforeSection)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .slice(0, 5); // Take top 5
      
      beforeLines.forEach(([line, count]) => {
        const confidence = count / analysisData.sections[section].found; // Normalize by section occurrence
        
        contextualPatterns[section].before.push({
          text: line,
          confidence: Math.min(confidence * 1.5, 0.8) // Scale up but cap at 0.8
        });
      });
      
      // Process lines that appear after the section
      const afterLines = Object.entries(contexts.afterSection)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .slice(0, 5); // Take top 5
      
      afterLines.forEach(([line, count]) => {
        const confidence = count / analysisData.sections[section].found; // Normalize by section occurrence
        
        contextualPatterns[section].after.push({
          text: line,
          confidence: Math.min(confidence * 1.5, 0.8) // Scale up but cap at 0.8
        });
      });
      
      console.log(`Generated ${contextualPatterns[section].before.length} before and ${contextualPatterns[section].after.length} after contextual patterns for ${section}`);
    });
    
    // Create pattern matcher file
    let patternMatcherCode = PATTERN_MATCHER_TEMPLATE;
    
    // Replace placeholders with actual patterns
    patternMatcherCode = patternMatcherCode.replace(
      'SECTION_PATTERNS_PLACEHOLDER',
      JSON.stringify(sectionPatterns, null, 2)
    );
    
    patternMatcherCode = patternMatcherCode.replace(
      'CONTEXTUAL_PATTERNS_PLACEHOLDER',
      JSON.stringify(contextualPatterns, null, 2)
    );
    
    // Write to file
    fs.writeFileSync(PATTERN_MATCHER_OUTPUT, patternMatcherCode);
    
    console.log(`Pattern matcher generated at ${PATTERN_MATCHER_OUTPUT}`);
    
    // Create a backup in pattern_repository
    const backupPath = path.join(
      path.dirname(ANALYSIS_RESULT_PATH),
      `PatternMatcher_${new Date().toISOString().replace(/[:.]/g, '-')}.js`
    );
    fs.writeFileSync(backupPath, patternMatcherCode);
    console.log(`Backup saved at ${backupPath}`);
    
  } catch (error) {
    console.error('Error generating pattern matchers:', error);
    process.exit(1);
  }
}

// Run the generator
generatePatternMatchers();
