/**
 * Prompt Output Evaluator
 * 
 * This module provides utilities for evaluating the quality of content
 * generated by LLMs using the prompt templates.
 */

import { DetailLevel, ReportStyle } from '../types';

/**
 * Evaluate the quality of generated content based on multiple criteria
 */
export function evaluatePromptOutput(
  sectionId: string,
  detailLevel: DetailLevel,
  style: ReportStyle,
  generatedContent: string
): EvaluationResult {
  // Initialize with perfect score and no issues
  let score = 10;
  const issues: string[] = [];
  
  // Check minimum content length based on detail level
  const minLengthResult = evaluateMinimumLength(detailLevel, generatedContent);
  if (!minLengthResult.success) {
    score -= 2;
    issues.push(minLengthResult.issue);
  }
  
  // Check maximum content length based on detail level
  const maxLengthResult = evaluateMaximumLength(detailLevel, generatedContent);
  if (!maxLengthResult.success) {
    score -= 1;
    issues.push(maxLengthResult.issue);
  }
  
  // Check writing style appropriateness
  const styleResult = evaluateStyle(style, generatedContent);
  if (!styleResult.success) {
    score -= 2;
    issues.push(styleResult.issue);
  }
  
  // Check for professional language
  const professionalLanguageResult = evaluateProfessionalLanguage(generatedContent);
  if (!professionalLanguageResult.success) {
    score -= 2;
    issues.push(professionalLanguageResult.issue);
  }
  
  // Check section-specific requirements
  const sectionSpecificResult = evaluateSectionSpecificRequirements(sectionId, generatedContent);
  if (!sectionSpecificResult.success) {
    score -= 2;
    issues.push(sectionSpecificResult.issue);
  }
  
  // Check for client-centered language
  const clientCenteredResult = evaluateClientCenteredLanguage(generatedContent);
  if (!clientCenteredResult.success) {
    score -= 1;
    issues.push(clientCenteredResult.issue);
  }
  
  // Ensure score doesn't go below 0
  score = Math.max(0, score);
  
  return {
    score,
    issues
  };
}

/**
 * Evaluate minimum content length based on detail level
 */
function evaluateMinimumLength(detailLevel: DetailLevel, content: string): CheckResult {
  const wordCount = countWords(content);
  let minimumWords = 0;
  
  switch (detailLevel) {
    case 'brief':
      minimumWords = 100;
      break;
    case 'standard':
      minimumWords = 250;
      break;
    case 'comprehensive':
      minimumWords = 500;
      break;
    default:
      minimumWords = 200;
  }
  
  return {
    success: wordCount >= minimumWords,
    issue: `Content is too short for ${detailLevel} detail level (${wordCount} words < ${minimumWords} minimum words)`
  };
}

/**
 * Evaluate maximum content length based on detail level
 */
function evaluateMaximumLength(detailLevel: DetailLevel, content: string): CheckResult {
  const wordCount = countWords(content);
  let maximumWords = 0;
  
  switch (detailLevel) {
    case 'brief':
      maximumWords = 300;
      break;
    case 'standard':
      maximumWords = 600;
      break;
    case 'comprehensive':
      maximumWords = 1500;
      break;
    default:
      maximumWords = 800;
  }
  
  return {
    success: wordCount <= maximumWords,
    issue: `Content is too long for ${detailLevel} detail level (${wordCount} words > ${maximumWords} maximum words)`
  };
}

/**
 * Evaluate appropriateness of writing style
 */
function evaluateStyle(style: ReportStyle, content: string): CheckResult {
  const contentLower = content.toLowerCase();
  
  switch (style) {
    case 'clinical':
      // Check for clinical terminology and formal language
      const clinicalTerms = [
        'assessment', 'evaluation', 'intervention', 'diagnosis', 'prognosis',
        'functional', 'deficit', 'impairment', 'limitation', 'rehabilitation'
      ];
      
      const clinicalTermCount = clinicalTerms.filter(term => 
        contentLower.includes(term)
      ).length;
      
      const hasClinicalLanguage = clinicalTermCount >= 3;
      
      // Check for conversational language that shouldn't be in clinical style
      const conversationalTerms = [
        'chat', 'talk about', 'let\'s', 'we\'ll', 'like I said',
        'anyway', 'basically', 'you know', 'sort of', 'kind of'
      ];
      
      const conversationalTermCount = conversationalTerms.filter(term => 
        contentLower.includes(term)
      ).length;
      
      return {
        success: hasClinicalLanguage && conversationalTermCount === 0,
        issue: !hasClinicalLanguage ? 
          'Clinical style lacks professional clinical terminology' : 
          'Clinical style contains inappropriate conversational language'
      };
      
    case 'conversational':
      // Check for plain language explanations
      const hasPlainLanguageExplanations = 
        contentLower.includes('this means') || 
        contentLower.includes('in other words') || 
        contentLower.includes('simply put') ||
        contentLower.includes('to put it simply') ||
        contentLower.includes('which is');
      
      // Check if it's still professional while being conversational
      const unprofessionalTerms = [
        'gonna', 'wanna', 'ain\'t', 'y\'all', 'dude',
        'cool', 'awesome', 'stuff', 'things', 'like'
      ];
      
      const unprofessionalTermCount = unprofessionalTerms.filter(term => 
        contentLower.includes(` ${term} `) // Match whole words
      ).length;
      
      return {
        success: hasPlainLanguageExplanations && unprofessionalTermCount === 0,
        issue: !hasPlainLanguageExplanations ? 
          'Conversational style lacks plain language explanations' : 
          'Conversational style contains unprofessional terminology'
      };
      
    case 'simplified':
      // Check for simplified language
      const sentenceCount = content.split(/[.!?]+/).length - 1;
      const averageWordsPerSentence = countWords(content) / Math.max(1, sentenceCount);
      
      // Check for use of complex words
      const complexWords = [
        'subsequently', 'additionally', 'furthermore', 'nevertheless',
        'consequently', 'notwithstanding', 'aforementioned', 'preliminary'
      ];
      
      const complexWordCount = complexWords.filter(word => 
        contentLower.includes(word)
      ).length;
      
      return {
        success: averageWordsPerSentence <= 15 && complexWordCount === 0,
        issue: averageWordsPerSentence > 15 ? 
          `Simplified style has sentences that are too long (average ${averageWordsPerSentence.toFixed(1)} words)` : 
          'Simplified style contains complex terminology'
      };
      
    default:
      return { success: true, issue: '' };
  }
}

/**
 * Evaluate use of professional language
 */
function evaluateProfessionalLanguage(content: string): CheckResult {
  const contentLower = content.toLowerCase();
  
  // Check for unprofessional or judgmental language
  const unprofessionalTerms = [
    'non-compliant', 'uncooperative', 'difficult patient', 'refuses to',
    'unwilling to', 'lazy', 'unmotivated', 'failed to', 'poor historian',
    'difficult case', 'problem patient', 'demanding', 'manipulative'
  ];
  
  for (const term of unprofessionalTerms) {
    if (contentLower.includes(term)) {
      return {
        success: false,
        issue: `Contains unprofessional term: "${term}"`
      };
    }
  }
  
  // Check for person-first language
  const nonPersonFirstTerms = [
    'disabled person', 'wheelchair bound', 'handicapped', 'confined to wheelchair',
    'victim of', 'suffers from', 'afflicted with', 'crippled'
  ];
  
  for (const term of nonPersonFirstTerms) {
    if (contentLower.includes(term)) {
      return {
        success: false,
        issue: `Contains non-person-first language: "${term}"`
      };
    }
  }
  
  return { success: true, issue: '' };
}

/**
 * Evaluate section-specific requirements
 */
function evaluateSectionSpecificRequirements(sectionId: string, content: string): CheckResult {
  const contentLower = content.toLowerCase();
  
  // Define required terms/concepts for each section
  const requiredTerms: Record<string, string[]> = {
    'initial-assessment': [
      'referred', 'assessment', 'purpose'
    ],
    'medical-history': [
      'diagnosis', 'condition', 'medical', 'health'
    ],
    'symptoms-assessment': [
      'pain', 'fatigue', 'symptom', 'report'
    ],
    'functional-status': [
      'mobility', 'independence', 'function', 'ability'
    ],
    'typical-day': [
      'morning', 'routine', 'activity', 'schedule'
    ],
    'environmental-assessment': [
      'home', 'environment', 'access', 'safety'
    ],
    'activities-daily-living': [
      'adl', 'self-care', 'independence', 'assistance'
    ],
    'attendant-care': [
      'care', 'assistance', 'support', 'caregiver'
    ]
  };
  
  // Check if content includes required terms for this section
  const termsForSection = requiredTerms[sectionId] || [];
  const includedTermsCount = termsForSection.filter(term => 
    contentLower.includes(term)
  ).length;
  
  // Require at least 50% of terms to be included
  const requiredTermCount = Math.ceil(termsForSection.length / 2);
  
  if (includedTermsCount < requiredTermCount) {
    return {
      success: false,
      issue: `Missing key content for ${sectionId} section (found only ${includedTermsCount}/${termsForSection.length} required terms)`
    };
  }
  
  return { success: true, issue: '' };
}

/**
 * Evaluate client-centered language
 */
function evaluateClientCenteredLanguage(content: string): CheckResult {
  const contentLower = content.toLowerCase();
  
  // Check for strength-based language
  const strengthBasedTerms = [
    'strength', 'ability', 'capable', 'resourceful', 'skill',
    'successful', 'achieve', 'manage', 'adapt', 'goal'
  ];
  
  const strengthBasedCount = strengthBasedTerms.filter(term => 
    contentLower.includes(term)
  ).length;
  
  // Check for deficit-focused language (some is appropriate, but shouldn't dominate)
  const deficitTerms = [
    'deficit', 'unable', 'cannot', 'impairment', 'limitation',
    'disability', 'restriction', 'problem', 'difficulty', 'challenge'
  ];
  
  const deficitCount = deficitTerms.filter(term => 
    contentLower.includes(term)
  ).length;
  
  // Should have at least some strength-based language and not overwhelmingly deficit-focused
  const isBalanced = strengthBasedCount > 0 && strengthBasedCount >= deficitCount / 2;
  
  if (!isBalanced) {
    return {
      success: false,
      issue: strengthBasedCount === 0 ? 
        'Content lacks strength-based language' : 
        'Content is overly deficit-focused without balancing strength-based language'
    };
  }
  
  return { success: true, issue: '' };
}

/**
 * Count words in text
 */
function countWords(text: string): number {
  return text.split(/\s+/).filter(word => word.length > 0).length;
}

/**
 * Interfaces for evaluation results
 */
interface CheckResult {
  success: boolean;
  issue: string;
}

export interface EvaluationResult {
  score: number;
  issues: string[];
}
